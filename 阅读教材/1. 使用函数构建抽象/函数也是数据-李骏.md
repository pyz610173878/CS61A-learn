放在 *functional* 这个大帽子下面是一系列围绕函数展开的思想，这些思想之间并没有很强的耦合，完全可以分开理解和应用。关于这些思想可以写好几本书，我们这里只开个头，重点介绍其中最重要的三个：**纯函数**（*pure functions*），**高阶函数**（*higher-order function*）和 **惰性计算**（*lazy evaluation*）

```
可以写好几本书，说明肯定有这方面的书籍。
```





### 特性 没有很强的耦合。完全可以分开理解和应用



# 纯函数

## #d 函数的副作用



首先使用文字描述出来。

函数的调用影响了除函数内以外的状态。那么这会导致什么问题呢？(它的危害)

是否有具体的例子可以说明呢？如何解决呢？

### 1. 例子

```
我自己无法举出在函数中创建和使用一个遍历，进而改变他的值。

我没有想到提出这两个问题。这才是标准答案。

如何在一个函数中创建或使用一个全局变量？
如何在其他函数中使用在一个函数中定义的全局变量？

```

```python
globvar = 0

def set_globvar_to_one():
    global globvar    # Needed to modify global copy of globvar
    globvar = 1

def print_globvar():
    print(globvar)     # No need for global declaration to read value of globvar

set_globvar_to_one()
print_globvar()       # Prints 1
```

### 2. 改变输入参数的值





### 重要概念

全局变量 *global variable*

**副作用** *side effect*

## #d 全局变量的危害





## 1. 定义

凡定义过的值，无法再进行更改。

从输入出发计算输出，输出结果只依赖于输入条件和函数体内定义的算法逻辑，不依赖于外界环境；同时函数除了给出计算结果外也不做任何其他事情，不影响函数以外的世界。这样的函数就是**纯函数**



## 2. 满足纯函数的函数具备的特征

1. 幂等（*idempotent*）：这是一个数学术语，意思是函数用相同的输入参数无论调用多少次，每次返回的结果都一样；
2. 无副作用（*without side effect*）：不会影响和改变函数体**以外**的状态，包括传入的参数。

不太严谨（但好理解）的说法：第 1 点排除了对函数以外环境的`依赖`，

第 2 点排除了对函数以外环境`影响`.他不会影响，其他代码的运行结果。



## 3. #d 纯函数的优势

### 3.1 

纯函数非常的**模块化**，往往更**简洁和易于测试**；

而纯函数层层调用时，只要保证每个函数的逻辑正确，整个链条就不会出问题，就像数学定理推演的严密逻辑一样

### 3.1 #d 优势2

纯函数还有一个巨大的优势：天然支持**并行计算**，无论多少台机器、多少 CPU  和核，以什么顺序调用一个纯函数，只要输入一样输出一定一样，调用之间不会影响，彼此独立的给出结果。这让我们可以放心地把一个大问题切割成无数小问题交给无数机器去算，然后把结果加起来就行。比如并行计算的工业先行者 Google，就利用 *functional* 思想构建了大型并行计算系统，来计算全世界每天数以亿计的网页上的信息数据



## 4. 代价

### 1. 

纯函数有时候不太好写，可能写出来非常难懂，尤其是处理和其他软件以及 I/O 设备（因为键盘鼠标显示器打印机这些都属于全局共享的资源，严格来说纯函数不能直接访问）有关的场景；



### 2. 

*Immutable values* 有时候会带来一定的资源和性能开销，比如因为变量不能重新赋值，导致传统的循环没法写了，必须改用递归（*recursive*）模式来写，相比起来会不那么直观，而且会占用更多内存



## 5. 解决办法

### 1. 

这两个问题都有解决方法，前者通过一种特殊的抽象方法，可以在不使用任何副作用的前提下操作外部资源（但说实话，相当抽象和难于理解），还有些编程语言干脆就放宽了特定场景下的限制，允许个别常用、危险可控的副作用（比如读写 I/O）；

### 2. 

后一个问题可以通过编译优化来降低资源消耗。



## 6. 适合函数式编程范型的应用

科学计算、机器学习等以数据处理和算法为核心的应用。很容易把算法和计算任务抽象为一组非常纯粹的函数；



## 老师的建议

Python 不是一个纯粹的函数式编程语言，也不强制使用纯函数，但我们强烈建议**尽可能保持函数是纯的，对不得不带有副作用的函数在文档中清晰说明副作用**





## 总结

这部分的阅读材料，指令性材料为主。没有太多的示例代码。没有示例代码说明不好举出实例代码，举出可能也无法理解。

你现在只是初步拆分了材料。并没有最细致的拆分。



不太想看，读了也可能理解不了。是吧





# 函数也是数据

函数和数字、字符串、布尔值之类的没什么两样，也是程序可以操作的一种数据，函数可以作为**参数**传给别的函数，也可以作为别的函数的**返回值**返回

## 1. *first-class function*

用作参数或返回值的函数叫做 *first-class function*，是指函数和别的数据没什么两样







## 2. *high-order function*

而把函数作为**输入参数**或者**返回值**的函数叫做 *high-order function*（可以翻译为“高阶函数”），意思是操作函数的函数



## 2.1 例子

<img src="%E5%87%BD%E6%95%B0%E4%B9%9F%E6%98%AF%E6%95%B0%E6%8D%AE-%E6%9D%8E%E9%AA%8F.assets/image-20221008164727361-16652188483501.png" alt="image-20221008164727361" style="zoom:67%;" />

```python
def apply(func, *args):
    return func(*args)


func是函数的简称

我们可以把函数用一个列表装起来。当需要使用时，就已某种方式，进行判断。这里目前我也没有太多的例子，可以举出来。先放在这里把。



```











### 1. 高阶函数与普通函数之间的区别

但是我们定义的高阶函数 `apply` 可以执行**任何传进来的函数**，而不需要在**写程序的**时候就确定，这是和直接调用 `max` 函数最大的区别。这在某些场景下非常有用。

```
哪些场景呢？
```



只能调用某一个特定的函数，而apply可以传递不只一个。







## 2.2 能够构造和返回函数的函数 复合函数

我们还可以定义另一种高阶函数，能够构造和返回函数的函数.复合函数





```python
lambda表达式写法
def comp2(f, g):
    return lambda x: f(g(x))
    
    
    
复合的参数特征。
1. 参数都是函数。
2. 返回值是一个函数的参数是另外一个函数的返回值。

    
def square(x):
    return x * x

def successor(x):
    return x + 1

def compose1(f, g):
    def h(x):
        return f(g(x))
    return h

def f(x):
    """Never called."""
    return -x

square_successor = compose1(square, successor)
square_successor(12)

144

 
 他们之间其实是互等的。lambda 相当于函数的嵌套。但如果用普通函数写，可以更好的理解。
```



### 2.1.1 尝试自己举出例子

如何写多参数的呢？





```
## 2.3 常用

### 2.3.1 map函数

### 2.3.2 reduce函数



### 2.3.3 分而治之 的经典模式

线索  MapReduce。

需求: 计算一篇文章里有多少个单词，第一就是他所采取的，定义数据形式的类型。列表与字符串的形式。

1. 使用列表的形式容纳数据。
2. 每一个句子，拆分成一个元素(字符串,一个索引值)。

文章就是所有句子组成的列表。







```python
def count(sentence):
    return len(sentence.split())


map(count, sentence)
```



### 2.3.4 filter函数

### 2.3.5 partial函数

# 惰性计算







