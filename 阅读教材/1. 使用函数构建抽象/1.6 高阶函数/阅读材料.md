# 1.6.1

## 例子1

找出他们的共性，比用代码进行表示出来。



<img src="%E9%98%85%E8%AF%BB%E6%9D%90%E6%96%99.assets/image-20220927082941478-16642385828761.png" alt="image-20220927082941478" style="zoom:50%;" />



<img src="%E9%98%85%E8%AF%BB%E6%9D%90%E6%96%99.assets/image-20220927082948133-16642385893443.png" alt="image-20220927082948133" style="zoom:50%;" />

三个函数中，共性都是 r * r * (某个数值)，r * r是一个固定的表达式。但最后一个数值是不固定的，所以我们把这个不固定的值，抽象成一个参数，这样我们就可以根据参数来灵活的进行修改



### 总结

假设多个函数中有重复的部分。我们一般的做法就是把他们之间的共性抽象成一个独立的模块(函数)。在这个例子中，area就是三个函数之间的共性。



## 例子2 关于求和

<img src="%E9%98%85%E8%AF%BB%E6%9D%90%E6%96%99.assets/image-20220927083917792-16642391586925.png" alt="image-20220927083917792" style="zoom: 50%;" />

```PYTHON
def sum_naturals(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + k, k + 1
        return total

    
求和函数。

    
    
        
def sum_cubes(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + k*k*k, k + 1
        return total
        
        
        
def pi_sum(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + 8 / ((4*k-3) * (4*k-1)), k + 1
        return total
    
    

  
不是瞎几把抽象。你得多观察是否代码与代码之间是否存在共性。如果存在共性，就可以进行泛化。    
通过这三个例子，我们找到了他们之间的共性，进一步泛化。


def <name>(n):
    total, k = 0, 1
    while k <= n:
        total, k = total + <term>(k), k + 1
    return total  

<term>(k)

```



### 1. 尝试描述整个思考过程



<img src="%E9%98%85%E8%AF%BB%E6%9D%90%E6%96%99.assets/image-20220927092238927-16642417599297.png" alt="image-20220927092238927" style="zoom:50%;" />

泛化的前提，多个事物之中存在共性，才能够进行泛化。

体现在编程的世界中就是**代码**中。

在这里例子中，分解成了两个模块(函数)，进行处理。通用的计算方法用一个函数表示，然后用term函数来进行求和。













## 总结

1. 视频只是把文本教材复述了一遍，并没有多余的东西。所以我可以先看文本教材，如果教材看不懂，我在看视频。

## example

```
我现在应该干嘛？我打算干嘛？
1. 我打算做笔记
2. 我想把这个模式记录下来。(有必要吗？)
貌似没有必要？为什么。




2. 还有一种方式。
就是尝试不看实例代码。我自己敲出来。这种方式难道不是更好吗？
首先，不看实例代码，但你也不能用记忆的方式来进行。你需要先把伪代码写出来。
```



首先一共有三种函数。

1. 把函数的返回值进行相加的函数，此函数不解决任何问题。解决问题的是，嵌套在函数体的另外一个函数。
2. 一个用来解决问题的函数(根据你自己的需求)，比如 返回绝对值 阶乘 幂平方
3. 此函数的参数，根据第二个函数的参数来决定。如果是两个就是两个如果是一个就是一个。
    1. 此函数的返回值。是把`函数的返回值进行相加的函数`。 函数1.











# 1.6.2 Functions as General Methods

```

我们介绍了用户定义的函数，作为抽象数字运算模式的机制，以便使它们独立于所涉及的特定数字。通过高阶函数，我们开始看到一种更强大的抽象：一些函数表达了一般的计算方法，与它们所调用的特定函数无关。

尽管在概念上扩展了函数的含义，但我们关于如何评估一个调用表达式的环境模型还是优雅地扩展到了高阶函数的情况，没有任何变化。当一个用户定义的函数被应用于一些参数时，形式参数被绑定到新的局部框架中这些参数的值（可能是函数）。

考虑一下下面的例子，它实现了一种用于迭代改进的一般方法，并使用它来计算黄金分割率。黄金比例，通常被称为 "phi"，是一个接近1.6的数字，经常出现在自然、艺术和建筑中。

迭代改进算法从对一个方程的解的猜测开始。它反复应用一个更新函数来改进这个猜测，并应用紧密比较来检查当前的猜测是否 "足够接近 "而被认为是正确的。
```





## 迭代改进的一般方法

我们介绍了用户定义的函数，作为抽象数字运算模式的机制，以便使它们独立于所涉及的特定数字。通过高阶函数，我们开始看到一种更强大的抽象：一些函数表达了一般的计算方法，与它们所调用的特定函数无关。

尽管在概念上扩展了函数的含义，但我们关于如何评估一个调用表达式的环境模型还是优雅地扩展到了高阶函数的情况，没有任何变化。当一个用户定义的函数被应用于一些参数时，形式参数被绑定到新的局部框架中这些参数的值（可能是函数）。

考虑一下下面的例子，它实现了一个用于迭代改进的一般方法，并使用它来计算黄金分割率。黄金比例，通常被称为 "phi"，是一个接近1.6的数字，经常出现在自然、艺术和建筑中。

迭代改进算法从对一个方程的解的猜测开始。它反复应用一个更新函数来改进这个猜测，并应用紧密比较来检查当前的猜测是否 "足够接近 "而被视为正确。

```PYTHON
def improve(update, close, guess=1):
        while not close(guess):
            guess = update(guess)
        return guess
    
    
    
我不太清楚，这几个参数的意义是什么？
我不清楚，黄金分割比，这个函数作为例子，我觉得我是看不懂的。
```

这个改进函数是一个重复细化的一般表达。它没有指定要解决什么问题：这些细节留给作为参数传入的更新和关闭函数。

众所周知，黄金比例的属性包括：它可以通过重复计算任何正数的逆数与1的和来计算，而且它比它的平方小1。我们可以将这些属性表达为与改进函数一起使用的函数。



# 1.6.5 Example: Newton's Method

这个扩展的例子显示了函数的返回值和局部定义是如何一起工作来简洁地表达一般的想法。我们将实现一种在机器学习、科学计算、硬件设计和优化中被广泛使用的算法。

牛顿方法是一种经典的迭代方法，用于寻找产生返回值为0的数学函数的参数，这些值被称为函数的零。找到一个函数的零点往往等同于解决其他一些感兴趣的问题，比如计算平方根。

在我们继续之前，有一个激励性的评论：我们很容易想当然地认为，我们知道如何计算平方根。不仅仅是Python，你的手机、网络浏览器或袖珍计算器都可以为你这样做。然而，学习计算机科学的一部分是了解像这样的量是如何计算的，这里介绍的一般方法适用于解决超出Python内置的一大类方程式。

牛顿方法是一种迭代改进算法：它改进了对任何可微的函数的零点的猜测，这意味着它可以在任何一点上被直线近似。牛顿方法遵循这些线性近似来寻找函数零点。

设想一条通过点（x,f(x)）的直线，其斜率与函数f(x)在该点的曲线相同。这样一条线被称为切线，其斜率被称为f在x处的导数。

这条线的斜率是函数值的变化与函数参数的变化的比率。因此，用f(x)平移x除以斜率就可以得到这条切线触及0的参数值





# 1.6.6 柯里化【Currying】& Uncurrying

我们可以使用高阶函数将一个需要多个参数的函数转换为一连串各需要一个参数的函数。

更具体地说，给定一个函数f(x, y)，我们可以定义一个函数g，使g(x)(y)等同于f(x, y)。这里，g是一个高阶函数，它接收一个单参数x，并返回另一个接收单参数y的函数，这种转换称为currying。

作为一个例子，我们可以定义一个curried版本的pow函数



```python
def curried_pow(x):
	def h(y):
		return pow(x, y)
    return h
curried_pow(2)(3)

```

```python
>>> def curry2(f):
        """Return a curried version of the given two-argument function."""
        def g(x):
            def h(y):
                return f(x, y)
            return h
        return g
    
    
    
>>> pow_curried = curry2(pow)
>>> pow_curried(2)(5)
```





# 1.6.7 Lambda Expressions

## 1. 使用lambda表示写复合函数





```
def cp2(f, g):
	return lambda x : f(g(x))
	
	
两个函数



result = cp2(add, mul)

result(5)
```









# 1.6.8  Abstractions and First-Class Functions

它们可以被绑定到名字上。
它们可以作为参数传递给函数。
它们可以作为函数的结果被返回。
它们可以被包含在数据结构中。

# 

