# 1. 看代码说输出结果

```python
>>> def xk(c, d):
...     if c == 4:
...         return 6
...     elif d >= 4:
...         return 6 + 7 + c
...     else:
...         return 25
>>> xk(10, 10)
// 23

>>> xk(10, 6)
// 23

>>> xk(4, 6)
// 17

>>> xk(0, 0)
// 25



>>> def how_big(x):
...     if x > 10:
...         print('huge')
...     elif x > 5:
...         return 'big'
...     elif x > 0:
...         print('small')
...     else:
...         print("nothin")
>>> how_big(7)
______

>>> how_big(12)
______

>>> how_big(1)
______

>>> how_big(-1)
______
```









# 阶层 falling

此函数有两个参数。根据参数二的自然数，返回参数1相对于的阶层。

## example 

```python
falling(6, 3)  # 6 * 5 * 4
    120
    >>> falling(4, 3)  # 4 * 3 * 2
    24
    >>> falling(4, 1)  # 4
    4
    >>> falling(4, 0)
    1
    
    
    
    
我现在看这个题目，就非常清晰。
他其实已经帮你拆解了整个需求了。


如何做到，









第一 你需要一个实现 从 本身逐步递减的这么一个功能 ，你自己想一想是可以想到range函数的。
第二 你需要 自身 * 自身。 我只想到了 pow，(想到pow的原因是，前面几道题，用到了pow，所以我会第一时间想到pow，但其实我可以在问自己，是否还有其他的函数可以使用。当时你卡了很久。
```

总的来说，递归背后的思维方式是将一个问题分解成更小的、类似的子问题，并使用递归来解决这些子问题。它需要仔细思考和关注细节，但可以成为解决复杂问题的有力工具。





## 改进函数，增加其通用性

1. 参数的设计

```
1. 一个参数。(给定一个自然数，然后从本身到1的阶层。)
本质上来说，差不多。
range函数可以实现相类似的。只要是关于(与什么相乘)方面的.


2. 列表参数(有必要吗？)我也不清楚，你得根据你自己的实际情况来是吧。改进不是瞎改进。
```

1. 返回值的设计
2. 

## 1. 看下别人设计的阶层函数 甚至别人写的模块

我想到一个点，内置函数中，不是有关于各种数学方面的函数吗？进一步其实各种实现的功能，当你没有思路的时候，直接去看官方写的，或者其他大佬写的，你直接去看他们的源码岂不是更好？

这个问题先记录下来。









当有思路时，如果十分钟这个思路还是行不通，或者写不出来，那就先放在那里。(过段时间看看)

第二，十分钟如果完全没有思路，先看`提示`，不要一次性就把答案看完了。





2. 总结

有了reduce函数，问题的复杂度一下子就降低了。

我只需要解决，两个参数之间的相乘，其他的就不需要管了。



























# sum_digits 求和

## 1. 理解问题

给定一个参数，参数只能是整数。

函数的作用，把参数拆分个位数，并进行相加，取之和数。



具体实例

```python
>>> sum_digits(10) # 1 + 0 = 1
    1
    >>> sum_digits(4224) # 4 + 2 + 2 + 4 = 12
    12
    >>> sum_digits(1234567890)
    45
    >>> a = sum_digits(123) # make sure that you are using return rather than print
    >>> a
    6
    """
    
    
    
说实话，完全想不到。


非常简单的两部，就解决了这个问题。
```





## 2. 写伪代码，简化题目。尝试与之相关的题目

product_of_digits。这个函数将一个给定数字的所有位数相乘。

count_digits。这个函数计算一个给定数字中的数字数量。

reverse_digits。这个函数将给定数字中的数字顺序颠倒过来。

is_palindrome。这个函数检查一个给定的数字是否是回文（即它的正向和反向读数是否相同）。

sum_of_squares: 这个函数计算给定数字中各数字的平方之和。



通用步骤。

这些函数都涉及到将一个数字分解成其组成数字





## 3. 完全没有思路怎么办？

### 1. 直接搜答案.

### 2. 把问题拆分进行搜索





## 4. 检查答案

是否能在别的题目或程序中利用这个方法或结果。

遇到类似的题目。就是把非个位数的自然数拆分个，单个自然数在进行相加的操作。



先不管了，解决不了了。











# double_eights

 我只能想到用正则规则。

## 1. 一些提示

`//` 的作用取整

`%`的作用取余数

example

299 





我觉得就用 %。能被8整除就返回true。否则返回false





## 1. 理解问题





## 2. 描述伪代码

* 转换成字符串形式
* 遍历字符串
* 重点就是匹配规则。如果
