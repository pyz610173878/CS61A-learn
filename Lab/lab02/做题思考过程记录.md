# lambda柯里化

## 1. 理解提问

在没有做题之前，脑中就传达了一个信号，这个题很难，你做不出来的。第一时间的我依然默认的接受了这个假定，不知如何，突然就激起了，以往的xx，我当时也是这么想的啊，但事实证明这是错误的啊！我能够理解的，也可以做出来的。只不过需要花费一点时间，多看几遍，就可以了。

```
目前的时间，还是不花在这方面了。学一些不是非常难的知识。你现在所学的知识，你确实可以看懂，但运用的场景会非常的少。
```

完全没得思路。说明你对柯里化是没有什么理解的。先把题目放在那里把。先做一些你能够解决的。

```
from operator import add, mul, mod
curried_add = lambda_curry2(add)
add_three = curried_add(3)
add_three(5)
8
```





## 2. 例子

```PYTHON
>>> lambda x: x  # A lambda expression with one parameter x
______

>>> a = lambda x: x  # Assigning the lambda function to the name a
>>> a(5)
______

>>> (lambda: 3)()  # Using a lambda expression as an operator in a call exp.
______

>>> b = lambda x: lambda: x  # Lambdas can return other lambdas!
>>> c = b(88)
>>> c
______

>>> c()
______




```





### 1. lambda返回lambda

具体作用:

你想用一个特定的行为来创建一个新的函数，但你不想为它定义一个命名的函数。在处理以函数为参数或以函数为返回值的高阶函数时，这可能特别有用。

```
>>> double = lambda x: lambda: x * 2


>>> my_double = double(3)
>>> my_double()
6


# 正常的写法


def double(x):
    return lambda: x * 2

>>> my_double = double(3)
>>> my_double()
6

```







### 2. lambda的参数是一个函数

```python
>>> d = lambda f: f(4)  # They can have functions as arguments as well.

>>> def square(x):
...     return x * x
>>> d(square)



def d(f):
    return f(4)
    
    
```



这其实就是复合函数的简便写法。









### 3. 函数的嵌套--lambda

```
>>> z = 3
>>> e = lambda x: lambda y: lambda: x + y + z
>>> e(0)(1)()
______

def e(x):
    def inner1(y):
        def inner2():
            z = 3
            return x + y + z
        return inner2
    return inner1




>>> f = lambda z: x + z
>>> f(3)
______


```





### 4. 高阶函数-lambda写法

```
>>> higher_order_lambda = lambda f: lambda x: f(x)
>>> g = lambda x: x * x
>>> higher_order_lambda(2)(g)  # Which argument belongs to which function call?
______

>>> higher_order_lambda(g)(2)
______

作用都是一样。



抽象一下。
1. 一个是函数。
2. 一个是函数的参数.
```







# Q2: 高阶函数

```
>>> def even(f):
...     def odd(x):
...         if x < 0:
...             return f(-x) ##返回函数其参数是负数
...         return f(x)      ## 返回函数本身
...     return odd
>>> steven = lambda x: x
>>> stewart = even(steven)

stewart


stewart(61)
// 61

stewart(-4)
// 4
```

* 他的参数是一个函数。
* 这个高阶函数的返回值，取决于被作为参数的函数的参数。
* 如果参数为正整数，返回参数本身
* 如果参数为负整数，返回参数的返回值。



比如，在上面那个例子中。

```
stewart = even(steven)
```

even是一个高阶函数，其参数是一个用lambda表达式书写的普通函数名为`steven`.其作用是返回参数本身的值。

而`even`的返回值就取决于，`steven`的参数，上述两个例子中。一个值为61，一个值为-4.我们把值代入，`odd`函数中，



我不知道他的具体应用范围。这个只能在你的项目或者其他方面，看看是否有具体应用的情况。



# 3. 函数柯里化

我们可以利用lambda表达式的优势，将多参数函数转化为一连串的【单参数】【高阶函数】。例如，我们可以把一个函数f(x, y)写成一个不同的函数g(x)(y)。这就是所谓的currying。



用处：

在处理那些只接受单参数的函数时，它很有用。我们在后面会看到一些这样的例子。





### 观察

这个lab作业。首先给你举很多例子。

例子。

练习。

实践









# 4. Count van Count

```
def count_factors(n):
    """Return the number of positive factors that n has.
    >>> count_factors(6)
    4   # 1, 2, 3, 6
    >>> count_factors(4)
    3   # 1, 2, 4
    """
    i, count = 1, 0
    while i <= n:
        if n % i == 0:
            count += 1
        i += 1
    return count
    
    
1. 设置两个变量。因为我们要从1开始遍历，所以设置一个循环的值。
2. count变量存储参数因数的【个数】。


最重要的一条代码就是判断规则。这个跟编程没有关系。跟数学有关系。能不能被整除嘛。

```



`count_factors`函数，返回参数因数的个数。 

因数的定义就是。是一种自然数与自然数之间的描述关系。

比如.   6的因数就有，2 3 6.为什么？能被6整除，就说明。那个数是6的因数，也叫做约数/







### 返回值--参数的素数个数

1. 返回参数因数的个数。
2. 写一个函数，使用count_factors，如果他的因数个数为2就说明这个数是个数。
3. 每次加+1。





```
def count_primes(n):
    """Return the number of prime numbers up to and including n.
    >>> count_primes(6)
    3   # 2, 3, 5
    >>> count_primes(13)
    6   # 2, 3, 5, 7, 11, 13
    """
    i, count = 1, 0
    while i <= n:
        if is_prime(i):
            count += 1
        i += 1
    return count

def is_prime(n):
    return count_factors(n) == 2 # only factors are 1 and n
    
    
素数的定义就是，只能1和自身整除。
相当于就是参数是不是只有两个因数。如果有两个因数，就说明他是因数。



```





